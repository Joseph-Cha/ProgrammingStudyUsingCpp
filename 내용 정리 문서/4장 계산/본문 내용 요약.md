## 학습 내용

- 여러 피연산자를 조합해 계산을 수행하는 방법
- 여러 대안 중 한 가지 행동을 택하는 방법
- 반복적으로 계산을 수행하는 방법
- 함수

## 4.1 계산

---

[**자료 구조의 뜻]**

입력을 처리하는데 필요한 데이터 

: 프로그램이 시작할 때부터 프로그램의 일부

: 또는 프로그램이 입력을 읽어서 쌓아둔 것

**[입력 처리]**

: 프로그램이 실행할 때 프로그램이 가지고 있을 수도 있다.

: 프로그램이 사용자가 입력한 데이터를 입력할 수 있다

**[출력 처리]**

: 다양하다.

> 프로그램을 어떻게 서로 협력하는 여러 부분의 집합으로 표현하는가? 각 부분들 사이에서 어떻게 데이터를 공유하고 교환하는가? 이런 질문이 바로 프로그래밍의 핵심이라 할 수 있다.

프로그램의 서로 다른 부분들?

→ 프로그램의 한 부분 : 함수

→ 서로 다른 함수가 어떻게 데이터를 공유하는지가 핵심이다!

**[인자]**

: 프로그램의 한 부분(함수)에 주어지는 입력

**[출력]** 

: 프로그램의 한 부분(함수)가 생성한 결과

**[계산]**

: 입력을 바탕으로 출력을 생성하는 과정

## 4.2 목적과 도구

---

**[프로그래머 직업의 목적]**

: 계산과정을 다음과 같은 방법으로 표현하는데 있다. (순서 중요)

1. 정확하게
2. 단순하게
3. 효율적으로

위의 순서가 중요하다. 

아무리 빨라도 결과가 정확하지 않다면? 

아무리 정확하고 효율적이라도 너무 복잡하다면?

유용한 프로그램일수록 새로운 요구 사항과 하드웨어 등을 고려한 수정이 필요

**[프로그램 조직화]**

프로그램을 잘 조직화할 때, 우리의 생각을 잘 정리하고 할 때 사용할 수 있는 방법

: 큰 계산을 작은 다수의 과정으로 나누는 것

⇒ **프로그램 조직화**를 위한 2가지 방법

1. 추상화

    : 직접 사용할 필요가 없는 상세한 내부 동작(상세 구현)은 편리하고 일반적인 인터페이스 뒤에 숨긴다. (ex. 전화부 내용을 정렬하기 위해서? → C++ 표준 라이브러리에서 sort 알고리즘을 호출만 하면 된다. 그저 호출하는 방법만 알면 된다)

2. 분할 정복

    : 덩치 큰 문제를 작은 문제로 나눈다.

어떻게 문제를 더 작은 부분으로 나눈지에 대한 예시를 배워야함 → 이 책을 통해 알 수 있음

**[분할할 때 주의사항]**

어떤 도구를 사용해서 분할 된 각 부분 자체와 각 부분 사이의 통신을 표현할 수 있는지 항상 고려해야한다. 즉 분할 된 각 부분들이 어떻게 서로 메시지를 주고 받을지 그리고 이를 위해 어떤 도구를 사용해야할지 고려해야한다.

ex. 라이브러리는 각 부분을 분산 시키는 데 큰 영향을 끼치기 때문에 부분끼리 어떻게 메시지를 주고 받을 수 있는지 라이브러리를 통해 결정해야한다.

**[마음 가짐]**

누군가의 삶과 일살을 책임질만한 코드를 작성하려면 많은 시간이 필요하다. 즉 올바른 학습의 일환으로 구조와 조직화를 강조하고자 한다.

개발에 있어서 추상적인 개념은 건너 뛰고 당장 손에 잡히는 유용한 부분만 배우고 싶은 유혹이 클 수 있다.

하지만 훌륭한 프로그래머와 시스템 설꼐자라면 구조에 대한 고려가 좋은 소프트웨어의 핵심이며, 구조를 무시하면 엄청나게 큰 **한 덩어리**의 프로그램이 만들어진다.

어느 정도 영속적인 무언가를 만들고 싶다면 실패에서 교훈을 얻기 보다 개발 과정에서 코드의 구조와 조직화를 지속적으로 고려해야한다.

## 4.3 표현식

---

**[표현식 의미]**

피연산자의 값으로부터 결과 값을 계산한다.

ex)

: 10, 'a', 3.14, "Norah"  등의 리터럴 값도 가장 단순한 형태의 표현식에 속한다.

: 변수의 이름도 표현식(cf. 변수는 해당 이름으로 명명된 객체를 가리킨다)

```cpp
// 넓이 계산:
int length = 20; // 정수 리터럴(을 이용한 변수 초기화)
int width = 40;
int area = length * width; // 곱셈
```

리터럴 20과 40으로 변수 `length`와 `width`를 초기화했다. 다음으로 `length`와  `width`를 곱했다. 즉, `length`와  `width`가 가리키는 값을 곱했다. 여기서 `length`는 'length라는 이름의 객체에 저장된 값'을 짥게 줄인 표현이다.

```cpp
length = 99; 
```

여기서 왼쪽 피연산자로 쓰인 length는 **이름이 length인 객체.**

위의 의미는 이름이 `length`인 객체에 99를 저장하라.

**[왼쪽 피연산자와 오른쪽 피연산자]**

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8c9a05a9-6f17-4913-8af8-006046cbbc1f/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8c9a05a9-6f17-4913-8af8-006046cbbc1f/Untitled.png)

**lvalue** 

**:** 대입문 왼쪽에 올 수 있는 객체를 가리키는 표현식. 값을 대입할 수 있는 모든 표현식이다.

**rvalue** 

: 대입문의 오른쪽에 올 수 있는 객체를 가리키는 표현식. 어떤 값이나 객체를 결과로 반환하는 모든 표현식.

위의 그림은 값 99를 저장하고 있는 int 타입의 객체 이름이 바로 length다. 

lvalue로 쓰이는 경우 ⇒ length는 상자(객체)를 가리킨다.

rvalue로 쓰이는 경구 ⇒ length는 상자 안의 값을 가리킨다.

같은 변수 이름이라도 때에 따라(위치에 따라) 의미가 다르다.

**[논리적 오류]**

컴파일러로는 찾아낼 수 없는 오류. 주로 표현식의 결과가 잘못되었기 때문에 나타남.

**[괄호 사용 시 원칙]**

의심스럽다면 괄호를 써라

너무 많이 남발하면 가독성을 떨어뜨린다.

→ 누군가가 나의 코드를 읽고 이해하기 어려울 수 있기 때문에

### 4.3.1 상수 표현식

---

**[상수 사용 원칙]**

 : 의미 있는 이름을 붙이자

 : 상수를 변경하는 실수를 하면 안된다. (pi와 같이 고정된 값에 사용해야하기 때문에)

→ C++에서 기호 상수 기능을 제공함 :  **~~constexpr~~ → const**

 : 상수 표현식이 아니지만(컴파일 시점에 값을 알 수 없지만), 초기화 이후로는 값을 변경할 수 없는 변수가 필요한 경우

```cpp
constexpr int max = 100;

void use(int n)
{
	constexpr int c1 = max + 7; // OK : c1은 107
	const int c2 = n + 7; // OK,  그러나 c2의 값을 바꿀 수는 없음
	//constexpr int c2 = n + 7; // error : c2 값을 모름
	//...
	c2 = 7; // 오류 : c2가 const
}
```

### 4.3.3 변환

---

**[부동소수점 나눗셈]**

Q? 5/2의 의미는 부동소수점으로 나눈 나눗셈일까 정수로 나눈 나눗셈일까?

부동 소수점이라면 5.0/2.0 = 2.5의 결과가 나올 것이고 정수로 나눈 나눗셈이라면 나머지를 버린 2일 것이다.

정답은 정보 손실을 막을 수 있는 부동소수점 나눗셈이다.

**[type(value)와 type{value}]**

공통점

 : 타입이 type인 변수를 value 값으로 초기화할 때처럼 value를 type으로 변환하라는 의미

차이점

 : **type{value}**는 축소 변환을 방지할 수 있지만 **type(value)**은 안된다.

 : 즉, 결과를 계산한 후에 다시 변환을 수행한다.

```cpp
double d = 2.5;
int i = 2;

double d2 = d/i;  // d2 == 1.25
int i2 = d/i;  // i2 == 1 (부동소수점 피연산자를 포함했지만 정수 나눗셈이 일어남)
int i3 {d/i} // error : double -> int 축소 변환

d2 = d/i; // d2 = 1.245
i2 = d/i; // i2 == 1
```

```cpp
// 섭씨를 화씨로 바꾸는 공식
// f = 9/5 * c + 32

double dc;
cin >> dc;
double df = 9/5*dc+32 // 주의! -> 9/5의 결과 값이 1임
double df = 9.0/5*dc+32 // 이처럼 9나 5를(또는 둘다!) 부동소수점으로 변환해줘야한다.
```

## 4.4 구문

---

**[표현식과 구문]**

표현식

 : 여러 개의 피연산자와 연산자를 이용해서 **하나의 결과 값**을 계산한다.

구문

 : 무언가를 여러 번 반복

 : 여러 대안 중 하나를 선택

 : 입력을 받거나 출력을 내보냄

**[표현식 구문과 선언 구문]**

표현식 구문

 : 세미 콜론으로 끝나는 표현식 (ex. a = b; , ++b;)

 : 예시에서 a = b는 자체로 표현식이지만 이 표현식이 구문이 되려면 뒤에 세미콜론(;)을 붙여야한다.

 : 대체적으로 대입문, I/O 구문, 함수 호출문 중 하나

**[구문 실행 순서]**

위에서부터 하나의 구문을 실행시킨다.

**[빈구문]**

```cpp
if (x == 5);
{ y = 3; } // 오류가 아니다!
```

이런 구문을 빈 구문이라고 하며 아무런 일도 하지 않는다.

### 4.4.1 선택

---

**[대안 선택]**

if 구문이나 switch 구문을 사용

**[if 구문 사용 시 주의]**

잘못된 입력을 항상 검사해야 한다.

```cpp
char unit = 0;
cin >> unit;

if (unit == 'i')
	cout >> "인치";
else
	cout >> "센치";

// 사용자가 i를 제외한 어떤 값을 입력해도 "센치"가 출력된다.
// 따라서 unit == 'c'인지를 검사해야 한다.
```

**[가슴에 새기는 말]**

어떤 식으로 어떤 복잡한 검사도 수행할 수 있다. 

그러나 코드가 추구하는 이상은 복잡함이 아니라 단순함이라는 점을 명심하자.

가장 복합한 코드를 작성해서 자신의 영리함을 입증하기보다,

주어진 일을 해내는 가장 단순한 코드를 작성함으로써 자신의 우수성을 입증하자. 

**[switch 구문 사용 시 주의]**

1. default 레이블을 사용하는 것이 좋다. 

    default 레이블을 반드시 사용해야하는 것은 아니나 모든 대안을 나열했다고 완벽히 자신하는 경우가 아니라면 default 레이블을 작성하는 것이 좋다.

2. 비교하는 값이 정수나 char, 열거형 타입이어야 한다.  

     string을 사용하는 경우는 if 구문이나 map을 이용하자

### 4.4.2 반복

---

**4.4.2.1 while 구문**

```cpp
while (i < 100)
{
		cout << i << '\t' << square(i) << endl;
		i++;
}
```

[**필요한 요소들]**

 : 구문을 반복할 수 있는 방법

 : 루프를 돈 횟수를 셀 수 있는 변수

 : 루프 변수의 초기 값

 : 종료 조건

 : 루프를 돌 때마다 실행할 무언가

**4.4.2.2  블록**

{  } 로 둘러싸인 일련의 구문을 블록이나 복합 구문이라고 한다.

**4.4.2.3 for 구문**

```cpp
int main()
{
		for (int i = 0; i < 100; ++i)
				cout << i << '\t' << square(i) << '\n';
}
				
```

**[while 문과 for 문]**

for 문 

 : 간단한 초기값과 조건문, 증간 연산을 이뤄진 for문으로 루프를 정의할 수 있는 경우에는 for 구문을 사용

while문

 : 위의 경우가 아닐 때 사용

## 4.5 함수

---

**[함수 정의 문법]**

타입 함수 이름 ( 매개변수 목록 ) 함수 몸체

매개변수 목록 : 함수가 요구하는 인자(형식 인자_formal argument)

### 4.5.1 함수의 필요성

**[함수의 필요성]**

- 계산 과정을 논리적으로 구별
- 프로그램 텍스트를 깔끔하게  → 복잡한 계산을 명명된 함수로 분리해 코드를 깔끔하게 하는 일
- 한 함수를 어려 번 사용
- 테스트를 쉽게

**[함수 정의 시 주의 사항]**

한 함수에서 논리적으로 단일한 작업을 수행하도록 해야 한다.

### 4.5.2 함수 선언

**[함수 선언]**

```cpp
int square(int x){...}
int x = square(44);
```

사실 함수 몸체를 볼 필요도 없다.

실제 프로그램에서는 함수 몸체를 볼 이유가 없는 경우가 흔하다.

함수를 사용하기만 하려면 함수 선언을 작성하거나(가장 최상단에 시그니처만 작성),

더 일반적으로는 #include를 이용해 함수 선언을 포함시킨다.

대규모 프로그램에서는 대부분 코드를 시야 밖으로 치워둠으로써 

각 부분의 코드에만 집중할 수 있게 함수 선언과 정의를 분리하는 일이 필수적이다.

## 4.6 vector

**[vector 정의]**

간단히 말하자면 인덱스로 접근할 수 있는 요소의 시퀀스다.

**[사용 방법]**

 : 요소 타입과 요소의 초기 값을 지정 < 타입 >

 : 요소의 값을 지정하지 않고 vector의 크기만 지정할 수도 있다.

```cpp
vector<int> vi(6); // 0으로 초기화된 int 6개를 포함하는 vector
vector<string> vs(4) // ""(빈 문자열)로 초기화된 문자열 4개를 포함하는 vector
```

 : vector 안에  존재하지 않는 요소를 참조할 수 없다.

```cpp
vi[20000] = 44; // 실행 시간 오류
```

실행 시간 오류와 첨자 연산에 대해서는 5장에서 

### 4.6.1 vector 탐색

```cpp
vector<int> v = {5, 7, 4, 3, 2, 1};
for (int i = 0; i < v.size(); i++
		cout << v[i] << endl;
```

**[vector.size()]**

vector의 크기를 알 수 있다.

v의 첫 요소는 v[0]

v의 마지막 요소는 v[v.size() -1]

만약 v.size() == 0이면 빈 vector

**[한쪽 끝이 열린 시퀀스 표기법]**

```cpp
vector<int> v = {5, 6, 3, 4, 2};
for(int x : v)
		cout << x << endl;
```

for(int x : v) : v에 포함된 각 x에 대해

**[0 : v.size()]**에서 첨자 연산을 수행하는 루프와 완전히 동일

### 4.6.2 vector 크기 증가

**[push_back()]**

처음에 빈 vector로 시작해서 필요한 데이터를 읽거나 계산하면서 vector의 크기를 키워가는 경우가 있다.

이때 사용하는 함수가 push_back()이다.

새로운 요소는 vector의 마지막 요소가 된다.

```cpp
vector<double> v;
v.push_back(2.7) // v[0] == 2.7
v.push_back(5.6) // v[1] == 5.6
v.push_back(7.9) // v[2] == 7.9
```

**[array와 차이점]**

vector는 미리 크기(길이)를 지정할 필요가 없다.

### 4.6.3 숫자를 이용한 예제

```cpp
// 온도를 vector에 읽어 들인다
int main()
{
		vector<double> temps;
		for (double temp; cin >> temp; )
				temps.push_back(temp);
		
		// 온도의 평균 계산
		double sum = 0;
		for (int x : temps) sum += x;
		cout << "온도 평균 : " << sum/temps.size() << '\n';
		
		// 온도의 중앙값 계산
		sort(temps); // 온도 정렬, 표준 라이브러리
		cout << "온도 중간 값 : " << temps[temps.size()/2] << '\n';
}
```

- vector<double> temps : 온도를 저장할 vector
- for (double temp; cin >> temp; )

    : double temp ⇒ 값을 읽어드릴 변수 temp

    : cin >> temp ⇒ 값을 올바르게(double 타입) 읽으면 참 아니면 거짓

    : ex) 1.2, 3.1, 4.2, 5.1, 5.7, @ (@에서 입력이 종료, double이 아닌 값이 오면 종료)

**[문자열 연산자]**

==, <, >, ≤, ≥ 모두 사용 가능

비교 기준은 사전식 순서이다.