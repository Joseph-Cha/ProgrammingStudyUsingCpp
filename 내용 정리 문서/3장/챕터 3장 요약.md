[문제 풀이](https://www.notion.so/da8b5f885ab5465db145dc2ed8100203)

### 1. 초기화와 대입의 차이

```cpp
int y = 9; // y를 9로 초기화
x = 9; // x에 9를 대입
```

초기화에서는 타입 지정이 앞에 오지만 대입에는 타입 지정이 없다는 점에서 구별할 수 있다.

원칙적으로 초기화를 수행할 때는 변수는 비어 있지만, 대입을 수행할 때는 **변수에 원래 남아 있던 값을 먼저 지워야한다.**

컴퓨터 메모리상의 리터럴에 대해서는 정확히 이와 같이 동작하진 않지만, 이런 식으로 동작한다고 이해해도 좋다.

> 프로그램의 흐름을 이해한느 방법 중의 하나가 '컴퓨터가 되보기', 즉 프로그램을 한 줄씩 그대로 따라가 보는 방법이다. 종이에 박스를 여러 개 그려놓고 변수의 값을 써 넣어보자. 그리고 프로그램의 흐름에 다라 저장된 값을 바꿔나가자.

적법하지 않은 이름(ex. 숫자로 시작, 특수문자, 띄어쓰기)은 컴파일러가 그 이름을 받아드리지 않는다.

C++에는 약 85개 키워드가 있다.

변수명 'x'는 지역 변수나 매개 변수로 사용한다.

i는 루프의 인덱스로 사용한다.

모두 대문자인 이름은 관례적으로 매크로에서 사용한다(매크로 자체도 되도록 피해야한다).

사용자 타입을 정의할 때는 첫 글자를 대문자로 한다. → C++ 언어와 표준 라이브러의와 구분 가능

### 3.8 타입과 객체

계산을 하는 동안 데이터를 저장하는 객체의 타입 관점에서

- 타입은 해당 객체의 가능한 값과 적용할 수 잇는 연산의 집합을 정의
- 객체는 주어진 타입의 값을 저장하는 메모리 공간
- 값은 주어진 타입으로 해석되는 메모리상의 비트의 집합
- 변수는 명명된 객체
- 선언은 객체의 이름을 지정하는 구문이다.
- 정의는 객체의 메모리 공간을 할당하는 선언의 일종

string은 문자의 갯수도 저장한다.

타입별로 차지하는 메모리 공간이 다르다.

- int : 4바이트(32비트)
- bool, char : 1바이트(8비트)
- double : 8바이트(64비트)
- string : char에 따라 차지하는 공간의 크기도 다르다.

메모리상의 비트들의 의미는 이에 접근할 때 사용하는 타입에 전적으로 의지한다. 컴퓨터는 타입에 대해 모르고 비트들은 단지 메모리 공간을 차지하고 있을 뿐이다. 메모리상의 비트는 비트를 해석하는 방법을 지정해야 비로소 의미를 얻는다.

### 3.9 타입 안정성

모든 객체는 정의하는 시점에서 정해진 타입이 있다 → 이 부분은 java와 js에는 해당 x듯

타입의 규칙에 따라 사용하면 타입 안정성이 있다고 한다. (ex. 초기화하지 않고 사용하면 타입 안정성이 없다고 한다.)

컴파일러가 안전성을 보장하지 않는 언어 기능(동적인 타입 안정성?)을 사용하지 않는 방법, 

즉, 정적 타입 안전성을 준수하는 방법이 이상적이지만, 대부분 프로그래밍 분야에서 그런 제약은 너무 제한적이다. → 왜냐하면 요즘 들어 나오는 프로그래밍 언어의 특징이 대부분 동적으로 타입을 지정하기 때문인 것 같다.

### 3.9.1 안전한 타입 변환

```cpp
double d1 = 2.3;
double d2 = d1 + 2; // 덧셈을 하기 전에 2를 2.0으로 변환함
if(d1 < 0) // 비교를 하기 전에 0을 0.0으로 변환함
	cout << "d1은 음수";
```

### 3.9.2 안전하지 않은 타입 변환

변환 과정에서 원래 값이 아닌 다른 값으로 바뀔 수도 있다는 의미

어떤 값을 저장하기에 너무 좁은 객체에 대입하는 경우를 축소 변환이라고 하는데 이 경우가 안전하지 않은 타입 변환이다.

```cpp
double → int 

int → char or bool

char → bool
```

C++ 11에서는 축소 변환을 방지하는 초기화 기법을 제공

```cpp
double x {2.7}; 
int y {x}; // 오류 : 구간을 벗어나는 축소 변환

int a {1000};
char b {a}; // 오류 : 구간을 벗어나는 축소 변환
```

{ } 초기화 수행자로 축소 변환의 사고를 예방하고 축소 변환이 필요한 경우에는 위의 예제와 같이 검사를 해야한다. 

(단 위의 예제에서 오류는 디버깅을 할 때 난다.)

{ } 목록을 이용한 초기화를 범용 균등 초기화라고도 한다.