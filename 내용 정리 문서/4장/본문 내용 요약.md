# Ch. 4 계산

- 여러 피연산자를 조합해 계산을 수행하는 방법
- 여러 대안 중 한 가지 행동을 택하는 방법
- 반복적으로 계산을 수행하는 방법
- 함수

## 4.1 계산

---

[**자료 구조의 뜻]**

입력을 처리하는데 필요한 데이터 

: 프로그램이 시작할 때부터 프로그램의 일부

: 또는 프로그램이 입력을 읽어서 쌓아둔 것

**[입력 처리]**

: 프로그램이 실행할 때 프로그램이 가지고 있을 수도 있다.

: 프로그램이 사용자가 입력한 데이터를 입력할 수 있다

**[출력 처리]**

: 다양하다.

> 프로그램을 어떻게 서로 협혁하는 여러 부분의 집합으로 표현하는가? 각 부분들 사이에서 어떻게 데이터를 공유하고 교환하는가? 이런 질문이 바로 프로그래밍의 핵심이라 할 수 있다.

프로그램의 서로 다른 부분들?

→ 프로그램의 한 부분 : 함수

→ 서로 다른 함수가 어떻게 데이터를 공유하는지가 핵심이다!

**[인자]**

: 프로그램의 한 부분(함수)에 주어지는 입력

**[출력]** 

: 프로그램의 한 부분(함수)가 생성한 결과

**[계산]**

: 입력을 바탕으로 출력을 생성하는 과정

## 4.2 목적과 도구

---

**[프로그래머 직업의 목적]**

: 계산과정을 다음과 같은 방법으로 표현하는데 있다. (순서 중요)

1. 정확하게
2. 단순하게
3. 효율적으로

위의 순서가 중요하다. 

아무리 빨라도 결과가 정확하지 않다면? 

아무리 정확하고 효율적이라도 너무 복잡하다면?

유용한 프로그램일수록 새로운 요구 사항과 하드웨어 등을 고려한 수정이 필요

**[프로그램 조직화]**

프로그램을 잘 조직화할 때, 우리의 생각을 잘 정리하고 할 때 사용할 수 있는 방법

: 큰 계산을 작은 다수의 과정으로 나누는 것

⇒ **프로그램 조직화**를 위한 2가지 방법

1. 추상화

    : 직접 사용할 필요가 없는 상세한 내부 동작(상세 구현)은 편리하고 일반적인 인터페이스 뒤에 숨긴다. (ex. 전화부 내용을 정렬하기 위해서? → C++ 표준 라이브러리에서 sort 알고리즘을 호출만 하면 된다. 그저 호출하는 방법만 알면 된다)

2. 분할 정복

    : 덩치 큰 문제를 작은 문제로 나눈다.

어떻게 문제를 더 작은 부분으로 나눈지에 대한 예시를 배워야함 → 이 책을 통해 알 수 있음

**[분할할 때 주의사항]**

어떤 도구를 사용해서 분할 된 각 부분 자체와 각 부분 사이의 통신을 표현할 수 있는지 항상 고려해야한다. 즉 분할 된 각 부분들이 어떻게 서로 메시지를 주고 받을지 그리고 이를 위해 어떤 도구를 사용해야할지 고려해야한다.

ex. 라이브러리는 각 부분을 분산 시키는 데 큰 영향을 끼치기 때문에 부분끼리 어떻게 메시지를 주고 받을 수 있는지 라이브러리를 통해 결정해야한다.

**[마음 가짐]**

누군가의 삶과 일살을 책임질만한 코드를 작성하려면 많은 시간이 필요하다. 즉 올바른 학습의 일환으로 구조와 조직화를 강조하고자 한다.

개발에 있어서 추상적인 개념은 건너 뛰고 당장 손에 잡히는 유용한 부분만 배우고 싶은 유혹이 클 수 있다.

하지만 훌륭한 프로그래머와 시스템 설꼐자라면 구조에 대한 고려가 좋은 소프트웨어의 핵심이며, 구조를 무시하면 엄청나게 큰 **한 덩어리**의 프로그램이 만들어진다.

어느 정도 영속적인 무언가를 만들고 싶다면 실패에서 교훈을 얻기 보다 개발 과정에서 코드의 구조와 조직화를 지속적으로 고려해야한다.

## 4.3 표현식

---

**[표현식 의미]**

피연산자의 값으로부터 결과 값을 계산한다.

ex)

: 10, 'a', 3.14, "Norah"  등의 리터럴 값도 가장 단순한 형태의 표현식에 속한다.

: 변수의 이름도 표현식(cf. 변수는 해당 이름으로 명명된 객체를 가리킨다)

```cpp
// 넓이 계산:
int length = 20; // 정수 리터럴(을 이용한 변수 초기화)
int width = 40;
int area = length * width; // 곱셈
```

리터럴 20과 40으로 변수 `length`와 `width`를 초기화했다. 다음으로 `length`와  `width`를 곱했다. 즉, `length`와  `width`가 가리키는 값을 곱했다. 여기서 `length`는 'length라는 이름의 객체에 저장된 값'을 짥게 줄인 표현이다.

```cpp
length = 99; 
```

여기서 왼쪽 피연산자로 쓰인 length는 **이름이 length인 객체.**

위의 의미는 이름이 `length`인 객체에 99를 저장하라.

**[왼쪽 피연산자와 오른쪽 피연산자]**

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8c9a05a9-6f17-4913-8af8-006046cbbc1f/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8c9a05a9-6f17-4913-8af8-006046cbbc1f/Untitled.png)

**lvalue** 

**:** 대입문 왼쪽에 올 수 있는 객체를 가리키는 표현식. 값을 대입할 수 있는 모든 표현식이다.

**rvalue** 

: 대입문의 오른쪽에 올 수 있는 객체를 가리키는 표현식. 어떤 값이나 객체를 결과로 반환하는 모든 표현식.

위의 그림은 값 99를 저장하고 있는 int 타입의 객체 이름이 바로 length다. 

lvalue로 쓰이는 경우 ⇒ length는 상자(객체)를 가리킨다.

rvalue로 쓰이는 경구 ⇒ length는 상자 안의 값을 가리킨다.

같은 변수 이름이라도 때에 따라(위치에 따라) 의미가 다르다.

**[논리적 오류]**

컴파일러로는 찾아낼 수 없는 오류. 주로 표현식의 결과가 잘못되었기 때문에 나타남.