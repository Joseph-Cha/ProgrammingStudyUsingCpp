# 5. 오류

## 5.1 소개

---

**[오류 분류]**

- 컴파일 시간 오류

    : 컴파일러가 찾아낸 오류(문법오류, 타입 오류)

- 링크 시간 오류

    : 목적 파일을 실행 프로그램에 통합하는 과정에서 링커가 찾아낸 오류

- 실행 시간 오류

    : 프로그램을 실행하는 동안 확인된 오류

    - 컴퓨터(하드웨어나 운영체제)가 감지한 오류
    - 라이브러리가 감지한 오류
    - 사용자 코드가 감지한 오류
- 논리 오류

    : 개발자가 잘못된 결과의 원인을 분석하는 과정에서 찾아낸 오류

**[오류에 대한 핵심 질문]**

이 프로그램이 그런 오류를 감지해야 하는가?

더 나아가서 아래와 같이 프로그램에 대해 가정해야 한다.

1. 모든 적법한 입력에 대해 요구받은 결과를 생성한다.
2. 모든 적접하지 않은 입력에 대해 적절한 오류 메시지를 출력한다.
3. 하드웨어의 오동작은 고려하지 않는다.
4. 시스템 소프트웨어의 오작동은 고려하지 않는다.
5. 오류를 감지한 후에는 종료해도 좋다.

**[오류를 어떻게 처리하는가?]**

- 소프트웨어를 **조직화**해서 오류를 최소화
- 우리가 만든 대부분의 오류를 **테스트**와 **디버깅**을 바탕으로 제거
- 남아있는 오류는 **사소한 오류**임을 확인

⇒ 이 세가지 중 하나만으로는 오류를 완벽하게 제거할 수 없으므로, 세 가지 방법을 모두 병행해야 한다.

⇒ 결국 최종적으로 우리는 항상 올바르게 작동하는 프로그램을 만들어야 한다.

⇒ 이 이상을 보통 달성하지 못한다고 해도 이것이 변명이 되어서는 안된다.

## 5.2 오류의 원인

---

**[오류의 원인]**

- 엉터리 명세

    : 프로그램이 해야할 일을 명확하게 명시하지 않는 것 

    ⇒ 모든 경우의 입력에 대해 처리했는지 명확하게 알기 어렵다.

- 불완전한 프로그램

    : 개발 과정에서 고려하지 않은 경우의 수가 있을 수 있다.

    ⇒ 피할 수 는 없지만 모든 경우를 처리했음을 확인하는 일을 목표로 해야함

- 예상 밖의 인자

    : 우리가 처리하지 않은 인자가 함수에 전달될 때

- 예상 밖의 입력

    : 일반적으로 프로그램은 데이터를 읽는다.(키보드, 파일, GUI, 네트워크 연결 등)

    : 프로그램은 이러한 입력에 대해 많은 가정을 해야 한다.

- 예상 밖의 상태

    : 대부분의 프로그램은 시스템의 서로 다른 부분(함수)에서 사용할 데이터를 유지

    : ex. 주소 목록, 전화번호부, 온두 측정 결과를 저장하는 vector 등

    : 이런 데이터가 불완전하거나 틀렸다면?

- 논리 오류

    : 코드가 의도한대로 작동하지 않는 경우.

    ⇒ 이런 경우는 찾아서 고치는 방법 밖에 없다.

**[오류 체크리스트]**

위 목록을 실무적으로 사용이 가능

⇒ 프로그램을 어느정도로 확인해야하는지에 대한 체크리스트가 될 수 있음

## 5.3 컴파일 시간 오류

---

**[컴파일 오류의 역할]**

기본적으로 1차 방어선 역할을 한다.

컴파일러는 목적코드를 생성하기 전 코드를 분석해서 **문법 오류**와 **타입 오류**를 찾아낸다.

대부분 오타나 편집 미완료로 인한 **단순 실수 오류**이다.

### 5.3.1 문법 오류

**[예시]**

```cpp
int area(int length, int width);

int s1 = area(7; // 오류 : ) 누락
int s2 = area(7) // 오류 : ; 누락
Int s3 = area(7); // 오류 : Int는 타입이 아님
int s4 = area('7); // 오류 : 종료하지 않은 문자(' 누락)
```

문법 오류가 발생한 경우에 컴파일러가 지적한 행에서 문제를 찾을 수 없다면 프로그램의 이전 행을 살펴보자

### 5.3.2 타입 오류

**[예시]**

```cpp
int area(int length, int width);

int x0 = arena(7); // 오류 : 선언하지 않은 함수
int x1 = area(7);  // 오류 : 인자의 수가 맞지 않음
int x2 = area("seven", 2); // 오류 : 첫 번째 인자의 타입이 올바르지 않음
```

문법 오류를 제거하고 나면 컴파일러가 타입 오류를 보고한다.

### 5.3.3 오류가 아닌 경우

**[오류가 아닌 경우]**

컴파일러가 보고하는 오류 중 일부를 오류가 아니라고 생각했을 수도 있다.

```cpp
int area(int length, int width);

int x3 = area(10, -7); // OK, 그러나 너비가 음수 7인 사각형이란 무슨 의미인가?
int x4 = area(10.7, 9.3); // OK, 그러나 area(10,9)를 호출함
int x5 = area(100, 9999); // OK, 그러나 결과를 축소 변환함
```

언어의 규칙 때문에(암묵적 형변환) 이 코드들을 완전히 거부할 수는 없지만 좋은 컴파일러라면 이에 대한 경고를 남긴다.

**[가슴에 새기는 말]**

경험이 쌍여가면서 컴파일러의 능력을 최대한 활용해서 오류를 찾아내고, 컴파일러의 알려진 약점을 피해가는 방법을 배우게 된다.

그러나 과신하지 말자.

내 프로그램이 컴파일됐다고 해서 프로그램이 실행되는 것을 의미하지는 않는다.

프로그램이 실행된다고 해도 논리적 결함을 찾아내기 전에는 잘못된 결과가 나오기 마련이다.

## 5.4 링크 시간 오류

---

**[링커 오류가 방지하는 2가지 규칙]**

1. 프로그램은 컴파일된 다수의 부분으로 이뤄진다.

    한 프로그램 안의 모든 함수는 그 함수를 사용하는 **모든 변환 단위에서 동일한 타입**으로 선언돼야 하며 이를 보장하기 위해 헤더 파일을 이용한다(인자 타입과 반환 타입이 동일해야함).

2. 모든 함수는 한 프로그램 안에서 딱 한 번 정의돼야 한다.

**[예시]**

```cpp
// 헤더 파일

int area(int length, int width)
```

```cpp
// main 
int main()
{
	int x = area(2,3);
}
```

다른 소스 파일(헤더파일)에서 area()를 정의한 후에 

그 소스 파일로부터 생성한 목적 코드를 위 프로그램의 목적 코드와 링크하지 않으면 

링커는 area()의 정의를 찾을 수 없다는 오류를 낸다.

 

**[주의 사항]**

돌이한 이름의 구성 요소는 딱 한 번 정의돼야 하고, 

선언은 여러 번 할 수 있지만 모든 선언의 타입은 정의한 타입과 동일해야 한다.

## 5.5 실행 시간 오류

---

### 5.5.1 호출하는 쪽(caller)에서의 오류 처리

특정 함수가 라이브러리 안에 포함된 함수여서 우리가 직접 수정할 수 없는 경우에

첫 번째 대안을 선택한다.

```cpp
if (x <= 0) error("x가 양수가 아님");
if (y <= 0) error("y가 양수가 아님");
int area1 = area(x,y);
```

여기서 사용한 error()함수는  std_lib_facilities.h에서 선언한 함수이다.

관련된 다른 함수가 보고 싶다면 runtime_error()를 사용해보자.

무튼 호출하기 전에 들어가는 인자의 값을 체크해서 오류를 처리할 수가 있다.

단 위와 같이 호출하는 쪽에서 인자를 체크하면 코드가 지저분해진다.

따라서 이럴 땐 검사하는 부분을 함수 안으로 옮기는 방법을 사용해야한다.

### 5.5.2 호출되는 쪽(callee)에서의 오류 처리

```cpp
int framed_area(int x, int y)
{
		constexpr int frame_width = 2;
		if (x - frame_width <= 0 || y - frame_width <= 0)
				error("frame_area()의 인자 때문에 양수가 아닌 인자로 area() 호출");
		return area(x - frame_width, y - frame_width);
}
```

이렇게 하면 호출할 때마다 오류를 체크하는 코드를 작성할 필요가 없다.

그리고 오류 처리 방법이 변경되더라도 코드 한 곳만 수정하면 된다.

**[함수 안에서 인자를 확인하는 일을 잘 안하는 이유?]**

- 함수 정의를 수정할 수 없다.

    : 라이브러리 안의 함수처럼 함수를 변경할 수 없는 경우가 있다.

- 호출되는 함수 안에서 오류를 어떻게 처리할지 알 수 없다.

    : 라이브러리 제작자가 오류를 감지할 수는 있지만. 오류가 일어났을 때 무슨 일을 해야 할지는 자신만이 알 수 있다.

- 호출되는 함수가 자신을 어디서 호출했는지 알 수 없다.

    : 실행 중인 프로그램이 어떤 경로로 오류를 냈는지는 알 수 없다. 구제적인 오류 메시지가 필요한 시점이다.

- 선능

    : 확인 코드로 인해 함수 크기가 두 배 이상 커진다(소스 코드의 길이는 물론 기계어의 수도 많아진다). 

### 5.5.3 오류 보고