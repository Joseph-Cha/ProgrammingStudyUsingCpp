# 5. 오류

## 5.1 소개

---

**[오류 분류]**

- 컴파일 시간 오류

    : 컴파일러가 찾아낸 오류(문법오류, 타입 오류)

- 링크 시간 오류

    : 목적 파일을 실행 프로그램에 통합하는 과정에서 링커가 찾아낸 오류

- 실행 시간 오류

    : 프로그램을 실행하는 동안 확인된 오류

    - 컴퓨터(하드웨어나 운영체제)가 감지한 오류
    - 라이브러리가 감지한 오류
    - 사용자 코드가 감지한 오류
- 논리 오류

    : 개발자가 잘못된 결과의 원인을 분석하는 과정에서 찾아낸 오류

**[오류에 대한 핵심 질문]**

이 프로그램이 그런 오류를 감지해야 하는가?

더 나아가서 아래와 같이 프로그램에 대해 가정해야 한다.

1. 모든 적법한 입력에 대해 요구받은 결과를 생성한다.
2. 모든 적접하지 않은 입력에 대해 적절한 오류 메시지를 출력한다.
3. 하드웨어의 오동작은 고려하지 않는다.
4. 시스템 소프트웨어의 오작동은 고려하지 않는다.
5. 오류를 감지한 후에는 종료해도 좋다.

**[오류를 어떻게 처리하는가?]**

- 소프트웨어를 **조직화**해서 오류를 최소화
- 우리가 만든 대부분의 오류를 **테스트**와 **디버깅**을 바탕으로 제거
- 남아있는 오류는 **사소한 오류**임을 확인

⇒ 이 세가지 중 하나만으로는 오류를 완벽하게 제거할 수 없으므로, 세 가지 방법을 모두 병행해야 한다.

⇒ 결국 최종적으로 우리는 항상 올바르게 작동하는 프로그램을 만들어야 한다.

⇒ 이 이상을 보통 달성하지 못한다고 해도 이것이 변명이 되어서는 안된다.

## 5.2 오류의 원인

---

**[오류의 원인]**

- 엉터리 명세

    : 프로그램이 해야할 일을 명확하게 명시하지 않는 것 

    ⇒ 모든 경우의 입력에 대해 처리했는지 명확하게 알기 어렵다.

- 불완전한 프로그램

    : 개발 과정에서 고려하지 않은 경우의 수가 있을 수 있다.

    ⇒ 피할 수 는 없지만 모든 경우를 처리했음을 확인하는 일을 목표로 해야함

- 예상 밖의 인자

    : 우리가 처리하지 않은 인자가 함수에 전달될 때

- 예상 밖의 입력

    : 일반적으로 프로그램은 데이터를 읽는다.(키보드, 파일, GUI, 네트워크 연결 등)

    : 프로그램은 이러한 입력에 대해 많은 가정을 해야 한다.

- 예상 밖의 상태

    : 대부분의 프로그램은 시스템의 서로 다른 부분(함수)에서 사용할 데이터를 유지

    : ex. 주소 목록, 전화번호부, 온두 측정 결과를 저장하는 vector 등

    : 이런 데이터가 불완전하거나 틀렸다면?

- 논리 오류

    : 코드가 의도한대로 작동하지 않는 경우.

    ⇒ 이런 경우는 찾아서 고치는 방법 밖에 없다.

**[오류 체크리스트]**

위 목록을 실무적으로 사용이 가능

⇒ 프로그램을 어느정도로 확인해야하는지에 대한 체크리스트가 될 수 있음

## 5.3 컴파일 시간 오류

---

**[컴파일 오류의 역할]**

기본적으로 1차 방어선 역할을 한다.

컴파일러는 목적코드를 생성하기 전 코드를 분석해서 **문법 오류**와 **타입 오류**를 찾아낸다.

대부분 오타나 편집 미완료로 인한 **단순 실수 오류**이다.

### 5.3.1 문법 오류

**[예시]**

```cpp
int area(int length, int width);

int s1 = area(7; // 오류 : ) 누락
int s2 = area(7) // 오류 : ; 누락
Int s3 = area(7); // 오류 : Int는 타입이 아님
int s4 = area('7); // 오류 : 종료하지 않은 문자(' 누락)
```

문법 오류가 발생한 경우에 컴파일러가 지적한 행에서 문제를 찾을 수 없다면 프로그램의 이전 행을 살펴보자

### 5.3.2 타입 오류

**[예시]**

```cpp
int area(int length, int width);

int x0 = arena(7); // 오류 : 선언하지 않은 함수
int x1 = area(7);  // 오류 : 인자의 수가 맞지 않음
int x2 = area("seven", 2); // 오류 : 첫 번째 인자의 타입이 올바르지 않음
```

문법 오류를 제거하고 나면 컴파일러가 타입 오류를 보고한다.

### 5.3.3 오류가 아닌 경우

**[오류가 아닌 경우]**

컴파일러가 보고하는 오류 중 일부를 오류가 아니라고 생각했을 수도 있다.

```cpp
int area(int length, int width);

int x3 = area(10, -7); // OK, 그러나 너비가 음수 7인 사각형이란 무슨 의미인가?
int x4 = area(10.7, 9.3); // OK, 그러나 area(10,9)를 호출함
int x5 = area(100, 9999); // OK, 그러나 결과를 축소 변환함
```

언어의 규칙 때문에(암묵적 형변환) 이 코드들을 완전히 거부할 수는 없지만 좋은 컴파일러라면 이에 대한 경고를 남긴다.

**[가슴에 새기는 말]**

경험이 쌍여가면서 컴파일러의 능력을 최대한 활용해서 오류를 찾아내고, 컴파일러의 알려진 약점을 피해가는 방법을 배우게 된다.

그러나 과신하지 말자.

내 프로그램이 컴파일됐다고 해서 프로그램이 실행되는 것을 의미하지는 않는다.

프로그램이 실행된다고 해도 논리적 결함을 찾아내기 전에는 잘못된 결과가 나오기 마련이다.

## 5.4 링크 시간 오류

---

**[링커 오류가 방지하는 2가지 규칙]**

1. 프로그램은 컴파일된 다수의 부분으로 이뤄진다.

    한 프로그램 안의 모든 함수는 그 함수를 사용하는 **모든 변환 단위에서 동일한 타입**으로 선언돼야 하며 이를 보장하기 위해 헤더 파일을 이용한다(인자 타입과 반환 타입이 동일해야함).

2. 모든 함수는 한 프로그램 안에서 딱 한 번 정의돼야 한다.

**[예시]**

```cpp
// 헤더 파일

int area(int length, int width)
```

```cpp
// main 
int main()
{
	int x = area(2,3);
}
```

다른 소스 파일(헤더파일)에서 area()를 정의한 후에 

그 소스 파일로부터 생성한 목적 코드를 위 프로그램의 목적 코드와 링크하지 않으면 

링커는 area()의 정의를 찾을 수 없다는 오류를 낸다.

 

**[주의 사항]**

돌이한 이름의 구성 요소는 딱 한 번 정의돼야 하고, 

선언은 여러 번 할 수 있지만 모든 선언의 타입은 정의한 타입과 동일해야 한다.

## 5.5 실행 시간 오류

---

### 5.5.1 호출하는 쪽(caller)에서의 오류 처리

특정 함수가 라이브러리 안에 포함된 함수여서 우리가 직접 수정할 수 없는 경우에

첫 번째 대안을 선택한다.

```cpp
if (x <= 0) error("x가 양수가 아님");
if (y <= 0) error("y가 양수가 아님");
int area1 = area(x,y);
```

여기서 사용한 error()함수는  std_lib_facilities.h에서 선언한 함수이다.

관련된 다른 함수가 보고 싶다면 runtime_error()를 사용해보자.

무튼 호출하기 전에 들어가는 인자의 값을 체크해서 오류를 처리할 수가 있다.

단 위와 같이 호출하는 쪽에서 인자를 체크하면 코드가 지저분해진다.

따라서 이럴 땐 검사하는 부분을 d함수 안으로 옮기는 방법을 사용해야한다.

### 5.5.2 호출되는 쪽(callee)에서의 오류 처리

```cpp
int framed_area(int x, int y)
{
		constexpr int frame_width = 2;
		if (x - frame_width <= 0 || y - frame_width <= 0)
				error("frame_area()의 인자 때문에 양수가 아닌 인자로 area() 호출");
		return area(x - frame_width, y - frame_width);
}
```

이렇게 하면 호출할 때마다 오류를 체크하는 코드를 작성할 필요가 없다.

그리고 오류 처리 방법이 변경되더라도 코드 한 곳만 수정하면 된다.

**[함수 안에서 인자를 확인하는 일을 잘 안하는 이유?]**

- 함수 정의를 수정할 수 없다.

    : 라이브러리 안의 함수처럼 함수를 변경할 수 없는 경우가 있다.

- 호출되는 함수 안에서 오류를 어떻게 처리할지 알 수 없다.

    : 라이브러리 제작자가 오류를 감지할 수는 있지만. 오류가 일어났을 때 무슨 일을 해야 할지는 자신만이 알 수 있다.

- 호출되는 함수가 자신을 어디서 호출했는지 알 수 없다.

    : 실행 중인 프로그램이 어떤 경로로 오류를 냈는지는 알 수 없다. 구제적인 오류 메시지가 필요한 시점이다.

- 성능

    : 확인 코드로 인해 함수 크기가 두 배 이상 커진다(소스 코드의 길이는 물론 기계어의 수도 많아진다). 

### 5.5.3 오류 보고

오류를 찾아냈다면 이제 무슨 일을 해야 할까?

**[오류 값 반환]**

원하는 결과 값이 나오지 않았을 때 특정 오류 값을 반환하는 방법

⇒ 호출 되는 쪽(함수 안)에서 세세하게 확인함은 물론 호출하는 쪽의 필요에 따라 오류를 처리

**[위 방법을 선택할 수 없는 이유]**

- 호출되는 함수와 호출하는 쪽 모두를 확인 해야 한다. 확인 후 실패 시에 어떻게 할지 정해야 한다.
- 호출하는 쪽에서 확인을 잊을 수도 있디. 이렇게 되면 프로그램이 실행할 때 결과를 예측할 수 없다.
- 오류를 나타내는 값(타입)으로 반환할 수 없는 함수도 많다.

    ⇒ return 타입이 int형인데 오류를 int타입으로 나타낼 수 없는 경우가 있다.

## 5.6 예외

---

**[예외의 기본적인 아이디어]**

오류 감지와 오류 처리를 분리함과 동시에 감지된 오류를 무시할 수 없게 하는 데 있다.

(오류 감지 : 호출되는 함수에서 수행해야 하는)

(오류 처리 : 호출하는 함수 쪽에서 수행해야 하는)

함수가 처리할 수 없는 오류가 발생하면 일반적인 return 값 대신 오류를 나타내는 예외를 throw한다.

문제의 함수를 직간접적으로 호출한 모든 함수에서 예외를 catch 해서 호출된 코드가 throw를 사용했을 때 무슨 일을 할지 정할 수 있다.

### 5.6.1 잘못된 인자

**[예시 1]**

```cpp
class Bad_area { }; // area()에서 오류 보고에 사용할 타입

// 사각형 넓이 계산
// 인자가 잘못된 경우 Bad_area 예외를 던짐
int area(int length, int width)
{
		if (length <= 0 || width <= 0) throw Bad_area { };
		return length * width;
}
```

인자에 문제가 있다면 호출하는 쪽에서 catch로 적절한 조치를 해주기 바라며 thow로 함수를 종료한다.

`throw Bad_area { };`는 **Bad_area{ }라는 객체를 만들어 throw하라**는 의미다.

**[예시 2]**

```cpp
int main()
try
{
		int x = -1;
		int y = 2;
		int z = 4;
		// ...
		int area1 = area(x,y);
		int area2 = framed_area(1,z);
		int area3 = framed_area(y,z);
		double ratio = area1/area3;
}
catch (Bad_area)
{
		cout << :"이런! area()에 잘못된 인자 전달됨!" << endl;
}
```

- 위 코드에서는 모든 area()의 호출에 대해서 예외처리를 할 수 있다.
- 오류처리와 오류 감지 부분이 얼마나 명확하게 분리됐는지에 주목하자.

    ⇒ main()은 어떤 함수가 throw Bad_area{ }를 실행했는지 모르며, area()도 자신을 throw한 Bad_area 예외를 어떤 함수가 catch하는지 알지 못한다. 

이러한 분리는 많은 라이브러리를 이용해서 작헝한 대규모 프로그램에서 특히 중요하다.

### 5.6.2 구간 오류

**[컨테이너]**

대부분 코드는 데이터 집합을 처리한다. 

즉, 처리할 데이터 요소를 포함하는 다양한 종류의 표와 목록을 이용한다.

C++에서는 이러한 데이터 모음을 **컨테이너**라고 한다.

대표적으로 vector가 표준 라이브러리 컨테이너이다.

**[구간 오류 발생]**

```cpp
vector<int> v(5);
int x = v[5];
```

위와 같이 vector의 범위를 벗어난 값으로 접근할 때 구간 오류가 발생한다.

```cpp
int main()
try
{
		vector<int> v;
		for (int x; cin >> x; )
			v.push_back(x);
		for (int i = 0; i <= v.size(); i++)
			cout << "v[" << i << "] == " << v[i] << endl;
} 
catch (out_of_range)
{
		cerr << "이런! 구간 오류 발생!" << endl;
}
```

### 5.6.3 잘못된 입력

 **[잘못된 입력을 처리하는 방법]**

인자 오류나 구간 오류를 처리할 때 사용한 기법과 언어의 기능을 동일하게 활용한다.

```cpp
double d = 0;
cin >> d;

if (cin)
{
		// 모두 정상. 다음 입력을 받을 수 있음
}
else 
{
		// 마지막 입력 실패. 다른 조치를 취해야 함
}

```

입력 연산이 실패하는 데는 여러 이유가 있겠지만 일단은 >>가 읽을 수 있는 double이 없을 경우이다.

**[어떻게 오류를 처리할 것인가?]**

```cpp
double some_function()
{
		double d = 0;
		cin >> d;
		if (!cin) error("'some_function'에서 double을 읽지 못함");
			// 필요한 작업을 실행
}
```

일단 위와 같이 개발 초기에는 어떤 이유로 오류가 나타났는지 알리고, 

나중에 해당 부분을 살펴보면서 더 적절한 조치를 행할 수 있다.

error()의 반환 값을 어떻게 사용해야 할지 모르기 때문에 값을 반환하진 않지만, 대신에 메시지를 출력한 후 프로그램을 바로 종료한다.

**[vector의 out_of_range]**

```cpp
int main()
try 
{
		// ... 프로그램 코드 ...
		return 0;
}
catch (runtime_error &e)
{
		cerr << "runtime error : " << e.what() << endl;
		keep_winow_open();
		return 1;  // 1은 실패를 의미
}
```

e.what()은 runtime_error로부터 오류 메시지를 가져온다.

catch (runtime_error &e)

여기서 &는 예외를 참조로 전달.

cerr은 오류 출력을 의미(이외 기능은 cout과 동일)

**[out_of_range와 runtime_error를 모두 잡기]**

out_of_range는 runtim_error가 아니므로, runtime_error만 잡아서는 

vector를 비롯한 표준 라이브러리의 컨테이너를 잘못 사용했을 때 발생하는 

out_of_range를 처리할 수 없다.

따라서 exception으로 잡으면 둘 다 처리할 수 있다.

```cpp
int main()
try
{
		// 프로그램 코드
		return 0;
}
catch (exception &e)
{
		cerr << "오류" << "e.what() << endl;
		keep_window_open();
		return 1; // 1은 실패를 의미
}
catch (...)
{
		cerr << "알 수 없는 예외!\n";
		keep_window_open();
		return 2; // 2는 실패를 의미
}
```

catch(...)를 추가해서 다른 모든 타입의 예외를 처리한다.

**[main()의 반환 값]**

main()의 반환 값이 프로그램을 실행한 시스템에 전달한다.

일부 시스템에서는 그 값을 사용하지만 다른 시스템에서는 그 값을 무시한다.

어쨋든 main()의 반환 값 0은 성공적인 완료를 0이 아닌 값은 실패를 의미한다.

### 5.6.4 축소오류

**[예외를 활용해서 runtime_error를 던지기]**

```cpp
int x1 = narrow_cast<int>(2.9); // 예외를 던짐
int x2 = narrow_cast<int>(2.0); // OK
char c1 = narrow_cast<char>(1066); // 예외를 던짐
char c2 = narrow_cast<char>(85); // OK
```

괄호 <...>는 어떤 개념에 대해 값이 아닌 타입을 지정할 때 사용

narrow_cast( )는 std_lib_facilities.h에 정의돼 있으며 error( )를 사용해서 구현

**[cast의 의미]**

cast는 타입 변환을 의미한다.

여기서 주의해야할 점은 피연사자를 변경하지 않는다는 점이다.

단지 피연산자의 값에 해당하는(<...>에 지정한 타입의) 새로운 값을 만들어 낸다.

## 5.7 논리 오류

컴파일러와 링커가 찾아낸 오류를 우선 제거하면 프로그램이 실행된다.

하지만 처음 이렇게 실행했을 때 아무런 결과가 나오지 않거나 의도하지 않은 출력의 결과가 나올 수도 있다.

이런 일이 일어난 원인은 프로그램을 구성하는 논리에 대한 이해 결함 때문일 수도 있다.

컴퓨터는 이미 내가 요구한 대로 동작하고 있기 때문에 나의 의도와 동작이 왜 다른지 밝혀내야 한다.

따라서 논리 오류가 찾아내기가 가장 어렵다.

## 5.8 평가

**[판단할 근거]**

대략적이라도 정답이 무엇인지를 생각해두지 않으면 프로그램의 결과가 옳은지 판단할 근거가 없다.

**[자신에게 던지는 질문]**

1. 특정 문제에 대한 해답이 적절한가?
2. 적절한 결과임을 어떻게 알 수 있는가?

여기서 우리는 완벽한 정답이나 올바른 답을 묻지는 않는다.

**[평가 논리]**

완벽한 답을 얻기 위한 평가가 아니라 나름 그럴 듯함을 확인한 후에 다음 단계로 진행하는 것을 의미한다.

때때로 적절한 계산을 수행하기 위해 필요한 데이터가 없이 작업을 해야할 때가 있는 데 이때 필요한 데이터를 추정하여 사용한다.

## 5.9 디버깅

**[디버깅을 위한 핵심적인 질문]**

> 프로그램이 정말 올바르게 동작하는지 어떻게 알 수 있을까?

이 질문에 답하는 데 도움이 되는 무엇이든 좋은 프로그램(디버깅을 최소화하고 정확하며 관리하기 쉬운)을 만드는 데 도움이 되므로, 앞으로도 계속해서 이런 질문을 던져야 한다.

기본적으로 버그가 숨을 곳이 없게 프로그램을 설계해야 한다.

프로그램을 구조화해서 오류의 가능성을 줄이고 소리 없이 생겨나는 오류를 쉽게 찾을 수 있도록 노력해야 한다.

### 5.9.1 실용적인 디버깅 조언

1. 코드 첫 행을 작성하기 전에 디버깅을 고려하라.
2. 오류를 어떻게 보고할지 결정하자.
3. 프로그램을 다음과 같이 읽게 쉽게 만들어서 버그를 발견할 가능성을 높이자.
    - 코드에 주석을 잘 달자. 코드에서 명확하게 드러나는 사실을 적는 것이 아니라 잘 드러나지 않는 사실을 최대한 명확하고 간결하게 설명
    - 프로그램 이름
    - 프로그램 목적
    - 누가, 언제 코드를 작성했는지
    - 버전 번호
    - 복잡한 코드 조각의 의도
    - 전반적인 설계 방식
    - 소스코드를 조직화한 방법
    - 입력에 대한 가정
    - 코드에서 빠진 부분과 처리하지 못하는 경우
    - 의미가 잘 드러난 네이밍
        - 단순히 긴 이름을 사용하라는 말이 아님
    - 코드 규칙을 일관되게 유지
    - 논리적으로 단일한 작업을 수행하는 함수 단위로 코드를 잘게 나누기
    - 코드를 복잡하게 나열하지 말자
        - 중첩된 루프와 중첩된 if 구문, 복잡한 조건문 등을 피하자.
    - 되도록 직접 코드를 작성하지 말고 라이브러리 기능을 활용
4. 컴파일을 해보자

    : 컴파일러는 보통 실제 오류가 있는 곳보다 뒤에서 오류를 보고한다.

5. 프로그램이 의도대로 동작하지 않는 이유를 찾아내는 과정을 거치자.

디버깅 기법도 제작하는 프로그램의 종류나 생각하는 방식의 차이에 따라 달라진다.

그래서 적어도 디버깅의 왕도는 없다.

하지만, 지저분한 코드에 버그가 숨어 있을 확률이 크다는 사실이다. 

코드를 되도록 간단하고 논리적이며, 형식에 맞게 유지하면 디버깅 시간을 줄일 수 있다.

## 5.10 사전 조건과 사후 조건

**[함수의 잘못된 인자 처리]**

함수를 호출하는 시점이 올바른 코드를 작성하고 오류를 작아내기에 가장 적합한 시점이다.

### 5.11 사전 조건

함수의 인자에 요구되는 조건을 사전 조건이라고 하며 함수를 제대로 실행하려면 이 조건을 반드시 반족해야 한다.

```cpp
int my_complicated_funtion(int a, int b, int c)
{
		// 인자는 a < b < c를 만족하는 양수임
		if (!0 < a && a < b && b < c)
				error("mcf의 인자가 잘못됨");
		// ...
}
```

우선 컴파일러를 통해 잘못된 인자가 들어왔는지 확인을 해준다.

```cpp
int x = my_complicated_funtion(1, 2, "my funtion");
```

여기서는 세 번째 인자가 정수라는 요구(사전 조건)가 위반 됐음을 알 수 있다.

하지만 컴파일러가 확인할 수 없는 사전 조건도 있다.

따라서 위와 같이 사전 조건을 주석에 항상 문서화 해야한다.

이를 통해 함수를 호출하는 쪽에서 사전 조건을 알 수 있다.

**[사전 조건을 확인(작성)하지 않는 이유]**

- 아무도 잘못된 인자를 줄 수 없다.
- 사전 조건 확인이 코드의 속도를 느리게 한다.
- 검사하기 너무 복잡하다

첫 번째 이유가 합리적이려면 함수를 누가 호출할지 알고 있어야 하는데 실제로 그런 경우는 거의 없다.

두 번째 이유는 대부분 섣부른 최적화의 예이다.

세 번째 이유는 심각하게 고려할 만하다.

사전 조건을 (주석으로라도) 작성하면 프로그램의 질을 높이는 데 큰 이득이 된다.

함수가 요구하는 바를 강제적으로 생각하게 만들기 때문이다.

주석에 사전 조건을 설명하고 사전 조건을 확인하는 코드를 넣으면 많은 설계 실수를 방지할 수 있다.

또한 함수 사용 시의 오류를 빨리 잡아내는 데 도움을 준다.

### 5.10.2 사후 조건

일반적으로 함수가 무엇을 반환하는지 명시해야만 한다.

즉, 함수가 어떤 값을 반환한다는 말은 반환 값에 대한 약속을 한다는 말과 같다.

(그렇지 않으면 함수를 호출하는 쪽에서 함수의 결과를 예측할 수가 없다.

```cpp
int area(int length, int width)
// 사각형 넓이 계산
// 사전 조건 : lengh와 width는 양수
// 사후 조건 : 넓이를 양수로 반환
{
		if (length <= 0 || width <= 0) error("area() 사전 조건");
		int a = length * width;
		if (a <= 0) error("area()사후 조건");
		return a;
}
```

사후 조건을 완벽히 확인하 수는 없지만, 적어도 결과가 양수라는 조건을 확인했다.

⇒ 불변 조건, 정확성, 테스팅과 밀접하게 관련됨

## 5.11 테스팅

**[테스팅이란?]**

디버깅뿐만 아니라 오류를 찾는 데도 체계적인 방법이 필요하다. 이를 **테스팅**이라고 한다.

기본적으로 테스팅은 체계적으로 선택된 다수의 입력으로 프로그램을 실행한 후에 

그 출력이 기대한 바와 같은지 확인한다.

주어진 한 가지 입력 집합으로 수행하는 테스트를 **테스트 케이스**라고 한다.

테스트 케이스는 체계적으로 선택해야 하며, 올바른 입력과 잘못된 입력을 모두 시도해야 한다.